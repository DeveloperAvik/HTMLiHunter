import requests
import argparse
import json
import os
import time
from bs4 import BeautifulSoup
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from colorama import Fore, Style, init

init(autoreset=True)

# === Payloads ===
payloads = [
    "<h1>injected123</h1>",
    "<div id='injected'>TEST</div>",
    "<img src=x onerror=alert('xss')>",
    "<svg/onload=alert(1)>",
    "<scr<script>ipt>alert(1)</script>",
]
custom_payloads = []
vulnerabilities = []

# === HTTP Headers ===
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/90.0.4430.93 Safari/537.36'
}

MAX_RETRIES = 3
RETRY_DELAY = 2

# === URL Param Helpers ===
def extract_params(url):
    parsed = urlparse(url)
    return list(parse_qs(parsed.query).keys())

def build_url_with_payload(url, param, payload):
    parsed = urlparse(url)
    query = parse_qs(parsed.query)
    query[param] = [payload]
    encoded_query = urlencode(query, doseq=True)
    new_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, encoded_query, parsed.fragment))
    print(Fore.BLUE + f"[DEBUG] Injected URL: {new_url}")
    return new_url

# === Selenium DOM Reflection Check ===
def check_in_dom(url, payload):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--disable-gpu')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')  # Optional for container environments

    try:
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        driver.get(url)
        time.sleep(1)
        if payload in driver.page_source:
            print(Fore.RED + f"[DOM] Payload found in DOM at {url}")
            return True
    except Exception as e:
        print(Fore.YELLOW + f"[!] DOM check error: {e}")
    finally:
        try:
            driver.quit()
        except:
            pass
    return False

# === Safe GET Request with Retry ===
def safe_get(url):
    for i in range(MAX_RETRIES):
        try:
            res = requests.get(url, headers=HEADERS, timeout=5)
            return res
        except requests.exceptions.RequestException as e:
            print(Fore.YELLOW + f"[!] GET error: {e}, retry {i+1}/{MAX_RETRIES}")
            time.sleep(RETRY_DELAY * (2 ** i))
    return None

# === Safe POST Request with Retry ===
def safe_post(url, data):
    for i in range(MAX_RETRIES):
        try:
            res = requests.post(url, data=data, headers=HEADERS, timeout=5)
            return res
        except requests.exceptions.RequestException as e:
            print(Fore.YELLOW + f"[!] POST error: {e}, retry {i+1}/{MAX_RETRIES}")
            time.sleep(RETRY_DELAY * (2 ** i))
    return None

# === Test GET ===
def test_get(url, param, payload):
    injected_url = build_url_with_payload(url, param, payload)
    res = safe_get(injected_url)
    if res and payload in res.text:
        if check_in_dom(injected_url, payload):
            vulnerabilities.append({
                "url": injected_url,
                "payload": payload,
                "method": "GET"
            })

# === Test POST ===
def test_post(url, form_data, payload):
    injected_data = {k: payload for k in form_data.keys()}
    res = safe_post(url, injected_data)
    if res and payload in res.text:
        if check_in_dom(url, payload):
            vulnerabilities.append({
                "url": url,
                "payload": payload,
                "method": "POST",
                "data": injected_data
            })

# === Form Discovery ===
def find_forms(url):
    try:
        res = requests.get(url, headers=HEADERS, timeout=5)
        soup = BeautifulSoup(res.text, "lxml")
        forms = soup.find_all("form")
        form_details = []
        for form in forms:
            inputs = form.find_all("input")
            data = {}
            for input_tag in inputs:
                name = input_tag.get("name")
                if name:
                    data[name] = "test"
            form_details.append(data)
        return form_details
    except Exception as e:
        print(Fore.YELLOW + f"[!] Error fetching forms: {e}")
        return []

# === Scan Controller ===
def scan_url(url):
    print(Fore.CYAN + f"[+] Scanning: {url}")
    all_payloads = payloads + custom_payloads

    # GET tests
    for param in extract_params(url):
        for p in all_payloads:
            test_get(url, param, p)

    # POST tests
    for form in find_forms(url):
        for p in all_payloads:
            test_post(url, form, p)

# === Save Results ===
def save_report():
    if vulnerabilities:
        with open("htmli_report.json", "w") as f:
            json.dump(vulnerabilities, f, indent=4)
        print(Fore.GREEN + f"[+] Report saved to htmli_report.json")
    else:
        print(Fore.YELLOW + "[+] No vulnerabilities found.")

# === Main ===
def main():
    parser = argparse.ArgumentParser(description="Advanced HTML Injection Scanner (GET + POST + DOM)")
    parser.add_argument("url", help="Target URL (with params or forms)")
    parser.add_argument("--payloads", help="Path to custom payloads.txt", default=None)
    args = parser.parse_args()

    if args.payloads and os.path.exists(args.payloads):
        with open(args.payloads) as f:
            custom_payloads.extend([line.strip() for line in f if line.strip()])

    scan_url(args.url)
    save_report()

if __name__ == "__main__":
    main()
