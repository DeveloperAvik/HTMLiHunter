#!/usr/bin/env python3
import requests
import argparse
import json
import os
import time
from bs4 import BeautifulSoup
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse, urljoin
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from colorama import Fore, Style, init

init(autoreset=True)

default_payloads = [
    "<h1>injected123</h1>",
    "<div id='injected'>TEST</div>",
    "<img src=x onerror=alert('xss')>",
    "<svg/onload=alert(1)>",
    # removed malformed payload
]

# === Globals ===
custom_payloads = []
vulnerabilities = []
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/90.0.4430.93 Safari/537.36'
}
MAX_RETRIES = 3
RETRY_DELAY = 2
REQUEST_TIMEOUT = 10  # more generous timeout
SESSION = requests.Session()
SESSION.headers.update(HEADERS)


def extract_params(url):
    parsed = urlparse(url)
    return list(parse_qs(parsed.query).keys())


def build_url_with_payload(url, param, payload):
    parsed = urlparse(url)
    query = parse_qs(parsed.query)
    query[param] = [payload]
    encoded_query = urlencode(query, doseq=True)
    new_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, encoded_query, parsed.fragment))
    print(Fore.BLUE + f"[DEBUG] Injected URL: {new_url}")
    return new_url


def check_in_dom(url, payload, headless=True):
    options = Options()
    if headless:
        options.add_argument('--headless=new')  # works with newer chrome
    options.add_argument('--disable-gpu')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    # minimize logs
    options.add_argument("--log-level=3")

    driver = None
    try:
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        driver.set_page_load_timeout(20)
        driver.get(url)
        time.sleep(1.5)
        page_src = driver.page_source or ""
        if payload in page_src:
            print(Fore.RED + f"[DOM] Payload found in DOM at {url}")
            return True
    except Exception as e:
        print(Fore.YELLOW + f"[!] DOM check error: {e}")
    finally:
        if driver:
            try:
                driver.quit()
            except Exception:
                pass
    return False


def safe_get(url):
    for i in range(MAX_RETRIES):
        try:
            return SESSION.get(url, timeout=REQUEST_TIMEOUT)
        except requests.exceptions.RequestException as e:
            print(Fore.YELLOW + f"[!] GET error: {e}, retry {i+1}/{MAX_RETRIES}")
            time.sleep(RETRY_DELAY * (2 ** i))
    return None


def safe_post(url, data, headers=None):
    for i in range(MAX_RETRIES):
        try:
            return SESSION.post(url, data=data, headers=headers, timeout=REQUEST_TIMEOUT)
        except requests.exceptions.RequestException as e:
            print(Fore.YELLOW + f"[!] POST error: {e}, retry {i+1}/{MAX_RETRIES}")
            time.sleep(RETRY_DELAY * (2 ** i))
    return None


def test_get(url, param, payload):
    injected_url = build_url_with_payload(url, param, payload)
    res = safe_get(injected_url)
    if res and payload in res.text:
        print(Fore.GREEN + f"[+] Reflection detected (GET) for param '{param}'")
        if check_in_dom(injected_url, payload):
            vulnerabilities.append({
                "url": injected_url,
                "payload": payload,
                "method": "GET"
            })


def test_post(form_meta, payload):
    """
    form_meta: dict with keys: action, method, fields (dict)
    """
    action = form_meta.get("action")
    method = form_meta.get("method", "post").lower()
    fields = form_meta.get("fields", {})
    injected_data = {k: payload for k in fields.keys()}

    # resolve relative actions
    if not urlparse(action).netloc:
        action = urljoin(form_meta.get("base_url", ""), action)

    print(Fore.BLUE + f"[DEBUG] Posting to {action} method={method} data_keys={list(injected_data.keys())}")
    if method == "post":
        res = safe_post(action, injected_data)
    else:
        # fallback to GET if form method is GET
        res = safe_get(action + "?" + urlencode(injected_data))
    if res and payload in res.text:
        print(Fore.GREEN + f"[+] Reflection detected (POST) for form action {action}")
        if check_in_dom(action if method == "get" else action, payload):
            vulnerabilities.append({
                "url": action,
                "payload": payload,
                "method": method.upper(),
                "data": injected_data
            })


# === Form Extraction ===

def find_forms(url):
    """
    Returns list of form metadata dicts:
    { action, method, fields (dict of name->default), base_url }
    """
    try:
        res = safe_get(url)
        if not res:
            return []
        soup = BeautifulSoup(res.text, "lxml")
        forms = soup.find_all("form")
        form_details = []
        for form in forms:
            action = form.get("action") or url  # default to page URL
            method = form.get("method", "get").lower()
            # collect inputs, textareas, selects
            fields = {}
            for input_tag in form.find_all(["input", "textarea", "select"]):
                name = input_tag.get("name")
                if not name:
                    continue
                # try to find default value if present
                value = input_tag.get("value") or ""
                fields[name] = value
            form_details.append({
                "action": action,
                "method": method,
                "fields": fields,
                "base_url": url
            })
        return form_details
    except Exception as e:
        print(Fore.YELLOW + f"[!] Error fetching forms: {e}")
        return []


# === Core Scan ===

def scan_url(url):
    print(Fore.CYAN + f"[+] Scanning: {url}")
    all_payloads = default_payloads + custom_payloads

    # GET params
    params = extract_params(url)
    if params:
        for param in params:
            for payload in all_payloads:
                test_get(url, param, payload)
    else:
        print(Fore.YELLOW + "[*] No query parameters found for GET tests.")

    # Forms
    forms = find_forms(url)
    if forms:
        for form in forms:
            for payload in all_payloads:
                test_post(form, payload)
    else:
        print(Fore.YELLOW + "[*] No forms found on page.")


def save_report():
    if vulnerabilities:
        with open("htmli_report.json", "w") as f:
            json.dump(vulnerabilities, f, indent=4)
        print(Fore.GREEN + f"[+] Report saved to htmli_report.json")
    else:
        print(Fore.YELLOW + "[+] No vulnerabilities found.")


def main():
    parser = argparse.ArgumentParser(
        description="Advanced HTML Injection Scanner (GET + POST + DOM)",
        usage="%(prog)s -u <URL> [--payloads payloads.txt]\n       %(prog)s -l <url_list.txt> [--payloads payloads.txt]"
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-u", "--url", help="Single target URL")
    group.add_argument("-l", "--list", help="Path to a file containing list of target URLs")
    parser.add_argument("--payloads", help="Path to custom payloads.txt", default=None)

    args = parser.parse_args()

    if args.payloads:
        if os.path.exists(args.payloads):
            with open(args.payloads) as f:
                custom_payloads.extend([line.strip() for line in f if line.strip()])
        else:
            print(Fore.RED + f"[!] Custom payloads file not found: {args.payloads}")
            return

    if args.url:
        scan_url(args.url)
    elif args.list:
        if not os.path.exists(args.list):
            print(Fore.RED + f"[!] URL list file not found: {args.list}")
            return
        with open(args.list) as f:
            urls = [line.strip() for line in f if line.strip()]
        for url in urls:
            scan_url(url)

    save_report()


if __name__ == "__main__":
    main()
