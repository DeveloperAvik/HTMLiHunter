import requests
import argparse
import json
import os
import time
from bs4 import BeautifulSoup
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from colorama import Fore, Style, init

init(autoreset=True)

default_payloads = [
    "<h1>injected123</h1>",
    "<div id='injected'>TEST</div>",
    "<img src=x onerror=alert('xss')>",
    "<svg/onload=alert(1)>",
    "<scr<script>ipt>alert(1)</script>",
]

# === Globals ===
custom_payloads = []
vulnerabilities = []
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
                  'Chrome/90.0.4430.93 Safari/537.36'
}
MAX_RETRIES = 3
RETRY_DELAY = 2



def extract_params(url):
    parsed = urlparse(url)
    return list(parse_qs(parsed.query).keys())


def build_url_with_payload(url, param, payload):
    parsed = urlparse(url)
    query = parse_qs(parsed.query)
    query[param] = [payload]
    encoded_query = urlencode(query, doseq=True)
    new_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, encoded_query, parsed.fragment))
    print(Fore.BLUE + f"[DEBUG] Injected URL: {new_url}")
    return new_url


def check_in_dom(url, payload):
    options = Options()
    options.add_argument('--headless')
    options.add_argument('--disable-gpu')
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')

    try:
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        driver.get(url)
        time.sleep(1)
        if payload in driver.page_source:
            print(Fore.RED + f"[DOM] Payload found in DOM at {url}")
            return True
    except Exception as e:
        print(Fore.YELLOW + f"[!] DOM check error: {e}")
    finally:
        try:
            driver.quit()
        except:
            pass
    return False


def safe_get(url):
    for i in range(MAX_RETRIES):
        try:
            return requests.get(url, headers=HEADERS, timeout=5)
        except requests.exceptions.RequestException as e:
            print(Fore.YELLOW + f"[!] GET error: {e}, retry {i+1}/{MAX_RETRIES}")
            time.sleep(RETRY_DELAY * (2 ** i))
    return None


def safe_post(url, data):
    for i in range(MAX_RETRIES):
        try:
            return requests.post(url, data=data, headers=HEADERS, timeout=5)
        except requests.exceptions.RequestException as e:
            print(Fore.YELLOW + f"[!] POST error: {e}, retry {i+1}/{MAX_RETRIES}")
            time.sleep(RETRY_DELAY * (2 ** i))
    return None



def test_get(url, param, payload):
    injected_url = build_url_with_payload(url, param, payload)
    res = safe_get(injected_url)
    if res and payload in res.text:
        if check_in_dom(injected_url, payload):
            vulnerabilities.append({
                "url": injected_url,
                "payload": payload,
                "method": "GET"
            })


def test_post(url, form_data, payload):
    injected_data = {k: payload for k in form_data.keys()}
    res = safe_post(url, injected_data)
    if res and payload in res.text:
        if check_in_dom(url, payload):
            vulnerabilities.append({
                "url": url,
                "payload": payload,
                "method": "POST",
                "data": injected_data
            })


# === Form Extraction ===

def find_forms(url):
    try:
        res = requests.get(url, headers=HEADERS, timeout=5)
        soup = BeautifulSoup(res.text, "lxml")
        forms = soup.find_all("form")
        form_details = []
        for form in forms:
            inputs = form.find_all("input")
            data = {}
            for input_tag in inputs:
                name = input_tag.get("name")
                if name:
                    data[name] = "test"
            form_details.append(data)
        return form_details
    except Exception as e:
        print(Fore.YELLOW + f"[!] Error fetching forms: {e}")
        return []


# === Core Scan ===

def scan_url(url):
    print(Fore.CYAN + f"[+] Scanning: {url}")
    all_payloads = default_payloads + custom_payloads

    for param in extract_params(url):
        for payload in all_payloads:
            test_get(url, param, payload)


    for form in find_forms(url):
        for payload in all_payloads:
            test_post(url, form, payload)



def save_report():
    if vulnerabilities:
        with open("htmli_report.json", "w") as f:
            json.dump(vulnerabilities, f, indent=4)
        print(Fore.GREEN + f"[+] Report saved to htmli_report.json")
    else:
        print(Fore.YELLOW + "[+] No vulnerabilities found.")



def main():
    parser = argparse.ArgumentParser(
        description="Advanced HTML Injection Scanner (GET + POST + DOM)",
        usage="%(prog)s -u <URL> [--payloads payloads.txt]\n       %(prog)s -l <url_list.txt> [--payloads payloads.txt]"
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-u", "--url", help="Single target URL")
    group.add_argument("-l", "--list", help="Path to a file containing list of target URLs")
    parser.add_argument("--payloads", help="Path to custom payloads.txt", default=None)

    args = parser.parse_args()

    if args.payloads:
        if os.path.exists(args.payloads):
            with open(args.payloads) as f:
                custom_payloads.extend([line.strip() for line in f if line.strip()])
        else:
            print(Fore.RED + f"[!] Custom payloads file not found: {args.payloads}")
            return


    if args.url:
        scan_url(args.url)
    elif args.list:
        if not os.path.exists(args.list):
            print(Fore.RED + f"[!] URL list file not found: {args.list}")
            return
        with open(args.list) as f:
            urls = [line.strip() for line in f if line.strip()]
        for url in urls:
            scan_url(url)


    save_report()


if __name__ == "__main__":
    main()
